package com.example.EngLang.Controller;

import com.example.EngLang.Service.TxtSubtitleReadService;
import com.example.EngLang.Service.TxtSubtitleWriteService;
import com.example.EngLang.Service.VideoSaveService;
import com.example.EngLang.Service.VideoUploadService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus; // Import HttpStatus
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;


@RestController
@RequestMapping("v1/EngLang")
@CrossOrigin(origins = "http://localhost:5173")
@RequiredArgsConstructor
public class File_Api {

    private final TxtSubtitleWriteService txtService;
    private final TxtSubtitleReadService txtReadService;
    private final VideoSaveService videoSaveService;
    private final VideoUploadService videoUploadService;

    @GetMapping(value = "/video-subtitle", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<Map<String, String>> downloadVideoAndSubtitle(@RequestParam String url) {
        Map<String, String> response = new HashMap<>();

        if (url == null || url.isEmpty()) {
            response.put("error", "URL boşdur. Xahiş olunur düzgün URL təmin edin.");
            return ResponseEntity.badRequest().body(response);
        }

        try {
            // STEP 1: Capture the MinIO filename returned by txtService.convertSubtitle()
            String subtitleMinioFileName = txtService.convertSubtitle(url);

            // STEP 2: Handle case where no subtitle was found/generated by yt-dlp
            if (subtitleMinioFileName == null) {
                // If txtService.convertSubtitle() returns null, it means no subtitle file was processed.
                // We will still proceed with video download if possible, but mark subtitle as missing.
                response.put("subtitleId", "no_subtitle_found");
                response.put("subtitle", ""); // Return empty subtitle
                System.out.println("Altyazı tapılmadı və ya emal edilmədi. Video URL: " + url);
                // No need to throw an error here, unless a subtitle is strictly required.
                // We'll continue to process the video.
            }

            // 2. Video'yu indir və MinIO’ya yükle
            String videoMinioFileName = videoSaveService.saveVideo(url); // Assuming this returns the MinIO filename for the video

            if (videoMinioFileName != null) {
                String videoUrl = videoUploadService.getPresignedUrl(videoMinioFileName, 60);
                response.put("minioFileName", videoMinioFileName); // This is the MinIO filename for the VIDEO
                response.put("videoUrl", videoUrl);

                // STEP 3: If a subtitle was processed, read it using its MinIO filename
                if (subtitleMinioFileName != null) {
                    // CORRECTED: Pass the generated subtitleMinioFileName to pullFile
                    byte[] subtitleContentBytes = txtReadService.pullFile(subtitleMinioFileName);
                    String subtitleText = new String(subtitleContentBytes, StandardCharsets.UTF_8);
                    response.put("subtitleId", subtitleMinioFileName); // Return the actual subtitle ID
                    response.put("subtitle", subtitleText);
                }
                // If subtitleMinioFileName was null, the 'response' map already has "subtitleId" and "subtitle" set accordingly.

                return ResponseEntity.ok(response);
            } else {
                response.put("error", "Video yükləmə zamanı xəta baş verdi.");
                System.err.println("Video MinIO-ya yüklənərkən xəta baş verdi. videoMinioFileName null-dır.");
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        } catch (Exception e) {
            response.put("error", "Video və ya altyazı emal edilərkən ümumi xəta: " + e.getMessage());
            System.err.println("Ümumi emal xətası: " + e.getMessage());
            e.printStackTrace(); // Always print stack trace for debugging
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }

    @PostMapping("/api/translate")
    public ResponseEntity<String> translate(@RequestBody Map<String, Object> body) {
        RestTemplate rest = new RestTemplate();
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> entity = new HttpEntity<>(body, headers);
        String result = rest.postForObject("http://localhost:5000/translate", entity, String.class);

        return ResponseEntity.ok(result);
    }
}
